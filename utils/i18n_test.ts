import i18n from 'i18next';

// Test-specific translations
const testResources = {
  ko: {
    translation: {
      test: {
        // Test status messages
        status: {
          testRunning: '테스트가 이미 실행 중입니다.',
          testStopped: '테스트가 중지되었습니다.',
          deviceConnected: '기기에 연결 중...',
          deviceConnectionFailed: '기기 연결 실패',
          deviceNotConnected: '기기가 연결되지 않았습니다.',
          connectionLost: '테스트 중 기기 연결이 끊어졌습니다.',
          serviceDiscovery: '서비스 확인 중...',
          protocolIdentification: '프로토콜 식별 중...',
          noProtocolDetected: '지원되는 프로토콜을 식별할 수 없습니다.',
          protocolIdentificationError: '프로토콜 식별 오류',
          ftmsFeaturesReadError: 'FTMS 기능 읽기 오류',
          rangeReadError: '범위 특성 읽기 오류',
          notificationSubscriptionError: '알림 구독 오류',
          controlPointTestError: '제어 포인트 테스트 오류',
          testError: '테스트 오류',
          criticalError: '치명적인 오류',
          waitingForPendingOperations: '대기 중인 작업 완료를 위해 3초 대기 중...',
          disconnectingPostTest: '테스트 후 기기 연결 해제 시도 중...',
          disconnectSuccess: '테스트 후 기기 연결 해제 성공',
          disconnectError: '테스트 후 기기 연결 해제 실패',
        },
        
        // Protocol-specific messages
        protocols: {
          mobi: {
            monitoring: 'Mobi 데이터 모니터링 중...',
            dataCollection: 'Mobi 데이터 수집 중... (페달을 계속 돌려주세요)',
            complete: 'Mobi 테스트 완료 (읽기 전용)',
            readOnly: 'Mobi 프로토콜 테스트 (읽기 전용)',
            setupComplete: 'Mobi 알림 설정 완료. 기기는 읽기 전용입니다 - 제어 명령이 전송되지 않습니다.',
          },
          reborn: {
            monitoring: 'Reborn 인증 및 데이터 모니터링 중...',
            dataCollection: 'Reborn 데이터 수집 중... 페달을 돌려주세요!',
            complete: 'Reborn 테스트 완료',
            authOnly: 'Reborn 프로토콜 테스트 (인증 + 데이터만)',
            skipControl: 'Reborn 제어 포인트 테스트 건너뛰기 (인증 전용 프로토콜)',
            pedalForData: 'Reborn 프로토콜 테스트를 위해 페달을 돌려 데이터를 생성해주세요.',
            setupComplete: 'Reborn 알림 설정 완료. 기기는 인증과 함께 읽기 전용입니다 - 제어 명령이 전송되지 않습니다.',
          },
          tacx: {
            monitoring: 'Tacx Neo 데이터 모니터링 중...',
            controlTest: 'Tacx Neo 사용자 상호작용 제어 기능 테스트 중...',
            dataCollection: 'Tacx Neo 데이터 수집 중...',
            complete: 'Tacx Neo 테스트 완료 (사용자 상호작용 제어 기능 포함)',
            withUserInteraction: 'Tacx Neo 프로토콜 테스트 (사용자 상호작용 제어 명령 포함)',
            userInteractionControl: 'Tacx Neo 사용자 상호작용 제어 포인트 테스트',
          },
          fitshow: {
            monitoring: 'FitShow 데이터 모니터링 중...',
            complete: 'FitShow 테스트 완료 (제어 기능 미포함)',
            withControl: 'FitShow 프로토콜 테스트 (제어 명령 포함)',
          },
          ftms: {
            supportRange: '지원 범위 확인 중...',
            dataFieldSetup: '데이터 필드 모니터링 설정 중...',
            controlTest: '제어 기능 테스트 중...',
            dataCollection: '데이터 수집 중...',
            compatibilityAnalysis: '호환성 분석 중...',
            complete: '테스트 완료',
            readingRanges: '지원 범위 읽기',
            finishedReadingRanges: '지원 범위 읽기 완료',
            subscribingNotifications: '알림 구독',
            subscribedAndCommandsSent: '알림 구독 및 초기 명령 전송 완료',
            controlPointTests: '제어 포인트 테스트',
            controlPointTestsCompleted: '제어 포인트 테스트 완료',
            dataCollectionPhase: '데이터 수집 단계',
            dataCollectionEnded: '데이터 수집 단계 종료',
          },
          csc: {
            monitoring: 'CSC 데이터 모니터링 중...',
            dataCollection: 'CSC 데이터 수집 중...',
            complete: 'CSC 테스트 완료 (제한된 기능)',
            setupComplete: 'CSC 알림 설정 완료',
          },
          noSupportedProtocols: '지원되는 프로토콜을 찾을 수 없습니다. 우선순위: MOBI > REBORN > TACX > FITSHOW > YAFIT_S3 > YAFIT_S4 > FTMS > CSC',
          incompatibleProtocol: '호환 불가능한 프로토콜',
        },
        
        // Control command messages
        controlCommands: {
          setSimParams: '시뮬레이션 파라미터 설정',
          setTargetPower: '목표 파워 설정',
          setResistanceLevel: '저항 레벨 설정',
          simParamsDescription: '경사 10%, 바람 0km/h로 설정합니다',
          targetPowerDescription: '목표 파워를 50W로 설정합니다',
          resistanceDescription: '저항 레벨을 40으로 설정합니다',
          executeCommand: '제어 명령 실행',
          resistanceCheck: '저항 변화 확인',
          resistanceCheckText: '명령 실행 후 실제로 저항이 변했는지 확인해주세요.',
          userCancelled: '사용자가 명령 실행을 취소했습니다',
          countdownStart: '명령 실행을 위한 3초 카운트다운 시작',
          countdown: '초 후 명령 실행',
          userInteractionNotSet: '사용자 상호작용 콜백이 설정되지 않음',
          resistanceChangeDetected: '사용자 확인: 저항 변화 감지됨',
          resistanceChangeNotDetected: '사용자 확인: 저항 변화 감지되지 않음',
          testComplete: '테스트 완료',
          success: '성공',
          failure: '실패',
          skipped: '건너뜀',
          pending: '대기 중',
        },
        
        // Data handling messages
        data: {
          gearLevel: '기어 레벨',
          batteryLevel: '배터리 레벨',
          resistanceChanged: '저항이 변경됨',
          fromTo: '에서',
          automaticChange: '자동 변경',
          delayed: '지연됨',
          notAttributedToCommand: '명령에 속하지 않음 - 자동 변경',
          commandRelated: '명령 관련',
          pendingCommand: '대기 중인 명령',
          completedCommand: '완료된 명령',
          attributionWindow: '속성 창',
          active: '활성',
          expired: '만료됨',
          remaining: '남음',
        },
        
        // Log messages
        logs: {
          deviceConnected: '기기에 성공적으로 연결됨',
          protocolsIdentified: '프로토콜 식별됨',
          allDetectedProtocols: '모든 감지된 프로토콜',
          primaryProtocol: '테스트용 주 프로토콜',
          ftmsFeaturesRead: 'FTMS 기능 읽기 시도',
          ftmsFeaturesRaw: 'FTMS 기능 원시 비트',
          ftmsFeaturesParsed: '파싱된 FTMS 기능',
          supportRangesRead: '지원 범위 읽기',
          speedRange: '속도 범위',
          inclineRange: '경사 범위',
          resistanceRange: '저항 범위',
          powerRange: '파워 범위',
          rangeNotAvailable: '범위를 사용할 수 없음',
          notificationsSetup: '알림 설정',
          initialCommandsSent: '초기 명령 전송됨',
          initialCommandsCompleted: '초기 명령 완료',
          controlPointTesting: '제어 포인트 테스트',
          controlPointTestsCompleted: '모든 제어 포인트 테스트 완료',
          dataCollectionStarted: '데이터 수집 단계 시작',
          dataCollectionEnded: '데이터 수집 단계 종료',
          pendingCommandsCheck: '대기 중인 명령 확인',
          noPendingCommands: '대기 중인 명령 없음',
          attributionWindowActive: '속성 창이 활성 상태',
          attributionWindowRemaining: '속성 창 남은 시간',
          commandStillPending: '명령이 여전히 대기 중',
          commandCompleted: '명령이 성공적으로 완료됨',
          commandFailed: '명령 실패',
          commandTimeout: '명령 시간 초과',
          noResponseWithinTimeout: '시간 초과 내 응답 없음',
          cpSuccessNoResistanceChange: 'CP 성공했지만 시간 초과 내 저항 변화 없음',
          resistanceChangeConfirmed: '저항 변화 확인됨',
          resistanceChangeNotConfirmed: '저항 변화 확인되지 않음',
          userInteractionTest: '사용자 상호작용 테스트',
          userInteractionTestComplete: '사용자 상호작용 테스트 완료',
          userCancelledCommand: '사용자가 명령 실행을 취소함',
          countdownStarted: '카운트다운 시작',
          commandExecuted: '명령 실행됨',
          resistanceCheckRequested: '저항 변화 확인 요청됨',
          userResponse: '사용자 응답',
          testResult: '테스트 결과',
        },
        
        // Error messages
        errors: {
          connectionError: '연결 오류',
          protocolIdentificationError: '프로토콜 식별 오류',
          ftmsFeaturesReadError: 'FTMS 기능 읽기 오류',
          rangeReadError: '범위 특성 읽기 오류',
          notificationSubscriptionError: '알림 구독 오류',
          controlPointTestError: '제어 포인트 테스트 오류',
          tacxControlTestError: 'Tacx 제어 테스트 오류',
          executionError: '실행 오류',
          userInteractionNotSet: '사용자 상호작용 콜백이 설정되지 않음',
          disconnectError: '연결 해제 오류',
        },
      },
    },
  },
  en: {
    translation: {
      test: {
        // Test status messages
        status: {
          testRunning: 'Test is already running.',
          testStopped: 'Test has been stopped.',
          deviceConnected: 'Connecting to device...',
          deviceConnectionFailed: 'Device connection failed',
          deviceNotConnected: 'Device is not connected.',
          connectionLost: 'Device connection lost during test.',
          serviceDiscovery: 'Checking services...',
          protocolIdentification: 'Identifying protocols...',
          noProtocolDetected: 'No supported protocols could be identified.',
          protocolIdentificationError: 'Protocol identification error',
          ftmsFeaturesReadError: 'FTMS features read error',
          rangeReadError: 'Range characteristic read error',
          notificationSubscriptionError: 'Notification subscription error',
          controlPointTestError: 'Control point test error',
          testError: 'Test error',
          criticalError: 'Critical error',
          waitingForPendingOperations: 'Waiting 3 seconds for pending operations to complete...',
          disconnectingPostTest: 'Attempting to disconnect device post-test...',
          disconnectSuccess: 'Device disconnected successfully post-test',
          disconnectError: 'Failed to disconnect device post-test',
        },
        
        // Protocol-specific messages
        protocols: {
          mobi: {
            monitoring: 'Monitoring Mobi data...',
            dataCollection: 'Collecting Mobi data... (Please keep pedaling)',
            complete: 'Mobi test complete (read-only)',
            readOnly: 'Mobi protocol testing (read-only)',
            setupComplete: 'Mobi notifications setup completed. Device is read-only - no control commands will be sent.',
          },
          reborn: {
            monitoring: 'Reborn authentication and data monitoring...',
            dataCollection: 'Collecting Reborn data... Please pedal!',
            complete: 'Reborn test complete',
            authOnly: 'Reborn protocol testing (authentication + data only)',
            skipControl: 'Skipping control point tests for Reborn (authentication-only protocol)',
            pedalForData: 'Please pedal to generate data for Reborn protocol testing.',
            setupComplete: 'Reborn notifications setup completed. Device is read-only with authentication - no control commands will be sent.',
          },
          tacx: {
            monitoring: 'Monitoring Tacx Neo data...',
            controlTest: 'Testing Tacx Neo user interaction control features...',
            dataCollection: 'Collecting Tacx Neo data...',
            complete: 'Tacx Neo test complete (with user interaction control features)',
            withUserInteraction: 'Tacx Neo protocol testing (with user interaction control commands)',
            userInteractionControl: 'Tacx Neo user interaction control point tests',
          },
          fitshow: {
            monitoring: 'Monitoring FitShow data...',
            complete: 'FitShow test complete (control features not included)',
            withControl: 'FitShow protocol testing (with control commands)',
          },
          ftms: {
            supportRange: 'Checking support ranges...',
            dataFieldSetup: 'Setting up data field monitoring...',
            controlTest: 'Testing control features...',
            dataCollection: 'Collecting data...',
            compatibilityAnalysis: 'Analyzing compatibility...',
            complete: 'Test complete',
            readingRanges: 'Reading supported ranges',
            finishedReadingRanges: 'Finished reading supported ranges',
            subscribingNotifications: 'Subscribing to notifications',
            subscribedAndCommandsSent: 'Subscribed to notifications and initial commands sent',
            controlPointTests: 'Control point tests',
            controlPointTestsCompleted: 'Control point tests completed',
            dataCollectionPhase: 'Data collection phase',
            dataCollectionEnded: 'Data collection phase ended',
          },
          csc: {
            monitoring: 'Monitoring CSC data...',
            dataCollection: 'Collecting CSC data...',
            complete: 'CSC test complete (limited features)',
            setupComplete: 'CSC notifications setup completed',
          },
          noSupportedProtocols: 'No supported protocols found. Priority: MOBI > REBORN > TACX > FITSHOW > YAFIT_S3 > YAFIT_S4 > FTMS > CSC',
          incompatibleProtocol: 'Incompatible protocol',
        },
        
        // Control command messages
        controlCommands: {
          setSimParams: 'Set Simulation Parameters',
          setTargetPower: 'Set Target Power',
          setResistanceLevel: 'Set Resistance Level',
          simParamsDescription: 'Set incline to 10%, wind to 0 km/h',
          targetPowerDescription: 'Set target power to 50W',
          resistanceDescription: 'Set resistance level to 40',
          executeCommand: 'Execute Control Command',
          resistanceCheck: 'Check Resistance Change',
          resistanceCheckText: 'Please check if the resistance has actually changed after executing the command.',
          userCancelled: 'User cancelled command execution',
          countdownStart: '3-second countdown for command execution',
          countdown: 'seconds until command execution',
          userInteractionNotSet: 'User interaction callback not set',
          resistanceChangeDetected: 'User confirmation: Resistance change detected',
          resistanceChangeNotDetected: 'User confirmation: Resistance change not detected',
          testComplete: 'Test complete',
          success: 'Success',
          failure: 'Failure',
          skipped: 'Skipped',
          pending: 'Pending',
        },
        
        // Data handling messages
        data: {
          gearLevel: 'Gear Level',
          batteryLevel: 'Battery Level',
          resistanceChanged: 'Resistance changed',
          fromTo: 'from',
          automaticChange: 'Automatic change',
          delayed: 'Delayed',
          notAttributedToCommand: 'Not attributed to command - automatic change',
          commandRelated: 'Command related',
          pendingCommand: 'Pending command',
          completedCommand: 'Completed command',
          attributionWindow: 'Attribution window',
          active: 'Active',
          expired: 'Expired',
          remaining: 'remaining',
        },
        
        // Log messages
        logs: {
          deviceConnected: 'Successfully connected to device',
          protocolsIdentified: 'Protocols identified',
          allDetectedProtocols: 'All detected protocols',
          primaryProtocol: 'Primary protocol for testing',
          ftmsFeaturesRead: 'Attempting to read FTMS features',
          ftmsFeaturesRaw: 'FTMS Features raw bits',
          ftmsFeaturesParsed: 'Parsed FTMS features',
          supportRangesRead: 'Reading support ranges',
          speedRange: 'Speed range',
          inclineRange: 'Incline range',
          resistanceRange: 'Resistance range',
          powerRange: 'Power range',
          rangeNotAvailable: 'Range not available',
          notificationsSetup: 'Notifications setup',
          initialCommandsSent: 'Initial commands sent',
          initialCommandsCompleted: 'Initial commands completed',
          controlPointTesting: 'Control point testing',
          controlPointTestsCompleted: 'All control point tests completed',
          dataCollectionStarted: 'Data collection phase started',
          dataCollectionEnded: 'Data collection phase ended',
          pendingCommandsCheck: 'Checking pending commands',
          noPendingCommands: 'No pending commands',
          attributionWindowActive: 'Attribution window active',
          attributionWindowRemaining: 'Attribution window remaining',
          commandStillPending: 'Command still pending',
          commandCompleted: 'Command completed successfully',
          commandFailed: 'Command failed',
          commandTimeout: 'Command timeout',
          noResponseWithinTimeout: 'No response within timeout',
          cpSuccessNoResistanceChange: 'CP success but no resistance change within timeout',
          resistanceChangeConfirmed: 'Resistance change confirmed',
          resistanceChangeNotConfirmed: 'Resistance change not confirmed',
          userInteractionTest: 'User interaction test',
          userInteractionTestComplete: 'User interaction test complete',
          userCancelledCommand: 'User cancelled command execution',
          countdownStarted: 'Countdown started',
          commandExecuted: 'Command executed',
          resistanceCheckRequested: 'Resistance change check requested',
          userResponse: 'User response',
          testResult: 'Test result',
        },
        
        // Error messages
        errors: {
          connectionError: 'Connection error',
          protocolIdentificationError: 'Protocol identification error',
          ftmsFeaturesReadError: 'FTMS features read error',
          rangeReadError: 'Range characteristic read error',
          notificationSubscriptionError: 'Notification subscription error',
          controlPointTestError: 'Control point test error',
          tacxControlTestError: 'Tacx control test error',
          executionError: 'Execution error',
          userInteractionNotSet: 'User interaction callback not set',
          disconnectError: 'Disconnect error',
        },
      },
    },
  },
  zh: {
    translation: {
      test: {
        // Test status messages
        status: {
          testRunning: '测试已在运行中。',
          testStopped: '测试已停止。',
          deviceConnected: '正在连接设备...',
          deviceConnectionFailed: '设备连接失败',
          deviceNotConnected: '设备未连接。',
          connectionLost: '测试期间设备连接丢失。',
          serviceDiscovery: '正在检查服务...',
          protocolIdentification: '正在识别协议...',
          noProtocolDetected: '无法识别支持的协议。',
          protocolIdentificationError: '协议识别错误',
          ftmsFeaturesReadError: 'FTMS功能读取错误',
          rangeReadError: '范围特征读取错误',
          notificationSubscriptionError: '通知订阅错误',
          controlPointTestError: '控制点测试错误',
          testError: '测试错误',
          criticalError: '严重错误',
          waitingForPendingOperations: '等待3秒让待处理操作完成...',
          disconnectingPostTest: '测试后尝试断开设备连接...',
          disconnectSuccess: '测试后设备成功断开连接',
          disconnectError: '测试后断开设备连接失败',
        },
        
        // Protocol-specific messages
        protocols: {
          mobi: {
            monitoring: '正在监控Mobi数据...',
            dataCollection: '正在收集Mobi数据...（请继续踩踏）',
            complete: 'Mobi测试完成（只读）',
            readOnly: 'Mobi协议测试（只读）',
            setupComplete: 'Mobi通知设置完成。设备为只读 - 不会发送控制命令。',
          },
          reborn: {
            monitoring: 'Reborn认证和数据监控...',
            dataCollection: '正在收集Reborn数据...请踩踏！',
            complete: 'Reborn测试完成',
            authOnly: 'Reborn协议测试（仅认证+数据）',
            skipControl: '跳过Reborn控制点测试（仅认证协议）',
            pedalForData: '请踩踏为Reborn协议测试生成数据。',
            setupComplete: 'Reborn通知设置完成。设备为带认证的只读 - 不会发送控制命令。',
          },
          tacx: {
            monitoring: '正在监控Tacx Neo数据...',
            controlTest: '正在测试Tacx Neo用户交互控制功能...',
            dataCollection: '正在收集Tacx Neo数据...',
            complete: 'Tacx Neo测试完成（包含用户交互控制功能）',
            withUserInteraction: 'Tacx Neo协议测试（包含用户交互控制命令）',
            userInteractionControl: 'Tacx Neo用户交互控制点测试',
          },
          fitshow: {
            monitoring: '正在监控FitShow数据...',
            complete: 'FitShow测试完成（不包含控制功能）',
            withControl: 'FitShow协议测试（包含控制命令）',
          },
          ftms: {
            supportRange: '正在检查支持范围...',
            dataFieldSetup: '正在设置数据字段监控...',
            controlTest: '正在测试控制功能...',
            dataCollection: '正在收集数据...',
            compatibilityAnalysis: '正在分析兼容性...',
            complete: '测试完成',
            readingRanges: '正在读取支持范围',
            finishedReadingRanges: '支持范围读取完成',
            subscribingNotifications: '正在订阅通知',
            subscribedAndCommandsSent: '已订阅通知并发送初始命令',
            controlPointTests: '控制点测试',
            controlPointTestsCompleted: '控制点测试完成',
            dataCollectionPhase: '数据收集阶段',
            dataCollectionEnded: '数据收集阶段结束',
          },
          csc: {
            monitoring: '正在监控CSC数据...',
            dataCollection: '正在收集CSC数据...',
            complete: 'CSC测试完成（功能有限）',
            setupComplete: 'CSC通知设置完成',
          },
          noSupportedProtocols: '未找到支持的协议。优先级：MOBI > REBORN > TACX > FITSHOW > YAFIT_S3 > YAFIT_S4 > FTMS > CSC',
          incompatibleProtocol: '不兼容的协议',
        },
        
        // Control command messages
        controlCommands: {
          setSimParams: '设置模拟参数',
          setTargetPower: '设置目标功率',
          setResistanceLevel: '设置阻力等级',
          simParamsDescription: '设置坡度10%，风速0 km/h',
          targetPowerDescription: '设置目标功率为50W',
          resistanceDescription: '设置阻力等级为40',
          executeCommand: '执行控制命令',
          resistanceCheck: '检查阻力变化',
          resistanceCheckText: '请检查执行命令后阻力是否实际发生变化。',
          userCancelled: '用户取消了命令执行',
          countdownStart: '命令执行3秒倒计时',
          countdown: '秒后执行命令',
          userInteractionNotSet: '用户交互回调未设置',
          resistanceChangeDetected: '用户确认：检测到阻力变化',
          resistanceChangeNotDetected: '用户确认：未检测到阻力变化',
          testComplete: '测试完成',
          success: '成功',
          failure: '失败',
          skipped: '跳过',
          pending: '等待中',
        },
        
        // Data handling messages
        data: {
          gearLevel: '齿轮等级',
          batteryLevel: '电池等级',
          resistanceChanged: '阻力已更改',
          fromTo: '从',
          automaticChange: '自动更改',
          delayed: '延迟',
          notAttributedToCommand: '不归因于命令 - 自动更改',
          commandRelated: '命令相关',
          pendingCommand: '待处理命令',
          completedCommand: '已完成命令',
          attributionWindow: '归因窗口',
          active: '活跃',
          expired: '已过期',
          remaining: '剩余',
        },
        
        // Log messages
        logs: {
          deviceConnected: '成功连接到设备',
          protocolsIdentified: '协议已识别',
          allDetectedProtocols: '所有检测到的协议',
          primaryProtocol: '测试的主要协议',
          ftmsFeaturesRead: '尝试读取FTMS功能',
          ftmsFeaturesRaw: 'FTMS功能原始位',
          ftmsFeaturesParsed: '解析的FTMS功能',
          supportRangesRead: '正在读取支持范围',
          speedRange: '速度范围',
          inclineRange: '坡度范围',
          resistanceRange: '阻力范围',
          powerRange: '功率范围',
          rangeNotAvailable: '范围不可用',
          notificationsSetup: '通知设置',
          initialCommandsSent: '初始命令已发送',
          initialCommandsCompleted: '初始命令完成',
          controlPointTesting: '控制点测试',
          controlPointTestsCompleted: '所有控制点测试完成',
          dataCollectionStarted: '数据收集阶段开始',
          dataCollectionEnded: '数据收集阶段结束',
          pendingCommandsCheck: '检查待处理命令',
          noPendingCommands: '无待处理命令',
          attributionWindowActive: '归因窗口活跃',
          attributionWindowRemaining: '归因窗口剩余',
          commandStillPending: '命令仍在待处理',
          commandCompleted: '命令成功完成',
          commandFailed: '命令失败',
          commandTimeout: '命令超时',
          noResponseWithinTimeout: '超时内无响应',
          cpSuccessNoResistanceChange: 'CP成功但超时内无阻力变化',
          resistanceChangeConfirmed: '阻力变化已确认',
          resistanceChangeNotConfirmed: '阻力变化未确认',
          userInteractionTest: '用户交互测试',
          userInteractionTestComplete: '用户交互测试完成',
          userCancelledCommand: '用户取消了命令执行',
          countdownStarted: '倒计时开始',
          commandExecuted: '命令已执行',
          resistanceCheckRequested: '已请求阻力变化检查',
          userResponse: '用户响应',
          testResult: '测试结果',
        },
        
        // Error messages
        errors: {
          connectionError: '连接错误',
          protocolIdentificationError: '协议识别错误',
          ftmsFeaturesReadError: 'FTMS功能读取错误',
          rangeReadError: '范围特征读取错误',
          notificationSubscriptionError: '通知订阅错误',
          controlPointTestError: '控制点测试错误',
          tacxControlTestError: 'Tacx控制测试错误',
          executionError: '执行错误',
          userInteractionNotSet: '用户交互回调未设置',
          disconnectError: '断开连接错误',
        },
      },
    },
  },
};

// Translation function for test-specific content
export const t = (key: string): string => {
  const currentLanguage = i18n.language || 'ko';
  const keys = key.split('.');
  let value: any = testResources[currentLanguage as keyof typeof testResources]?.translation;
  
  for (const k of keys) {
    if (value && typeof value === 'object' && k in value) {
      value = value[k];
    } else {
      // Fallback to Korean if translation not found
      value = testResources.ko.translation;
      for (const fallbackKey of keys) {
        if (value && typeof value === 'object' && fallbackKey in value) {
          value = value[fallbackKey];
        } else {
          return key; // Return the key if translation not found
        }
      }
      break;
    }
  }
  
  return typeof value === 'string' ? value : key;
};

export default testResources; 